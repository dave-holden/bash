# if command -v source; then
#   echo "Source command found"
#   source https://raw.githubusercontent.com/dave-holden/bash/main/core/shell_env.sh
#   source https://raw.githubusercontent.com/dave-holden/bash/main/output/spinners.sh
#   source https://raw.githubusercontent.com/dave-holden/bash/main/output/colours.sh
#   source https://raw.githubusercontent.com/dave-holden/bash/main/output/output.sh
# else
#   echo "Source command Not found"
#   . https://raw.githubusercontent.com/dave-holden/bash/main/core/shell_env.sh
#   . https://raw.githubusercontent.com/dave-holden/bash/main/output/spinners.sh
#   . https://raw.githubusercontent.com/dave-holden/bash/main/output/colours.sh
#   . https://raw.githubusercontent.com/dave-holden/bash/main/output/output.sh
# fi
# echo


shell_identity() {
  # Returns a string repr of the current operating SHELL
  
  # Explanation: ps -o ppid= -p $$ gives you the parent process id of 
  # the current running process ie script
  # env_shell=$( ps -p `ps -o ppid= -p $$` -o comm= )
  # # ps -p...-o comm= tells you the name of the process passed with -p.
  # echo ${env_shell}
  echo $( ps -p `ps -o ppid= -p $$` -o comm= )
}
is_valid_shell() {
  str="$1"
  found=false
  for i in bash zsh
  do 
    echo "$i === $str"
    if [ "$i" = "$str" ] ; then
      # echo "eq ${i} == ${str}"
      found=true
    break
    fi
  done
  echo $found

  return $([ $found = true ] &&  echo 0 || echo 1)
}

is_available() {
  echo "is_available : $@"
  found=false
  for i in zsh bash 
  do 
    echo "is_available :: I : $i"
    # if [ "$i" = "$str" ] ; then
    if "/usr/bin/env ${i}" "$@"; 
    then
      echo "is_available :: FOUND ${i}"
      # echo "eq ${i} == ${str}"
      found=true
      break
    else
      echo "is_available :: NOT FOUND ${i}"
    fi
    echo "NOT FOUND"
  done
  # echo $found

  return $([ $found = true ] &&  echo 0 || echo 1)
}

is_shell() {
  # Accepts a string argument of a name of shell :- Bash, Zsh
  
  shell_name=${1:-"bash"}
  
  shell_name=$(echo "$shell_name" | tr '[:upper:]' '[:lower:]')
  is_valid=$(is_valid_shell $shell_name )

  # if  ! $(is_valid_shell $shell_name ) ;
  # then
  #   echo "Error: Invalid shell name passed to 'is_shell' ${shell_name}"
  #   exit 1
  # fi
  result=$([ $(shell_identity) = ${shell_name} ] &&  echo true || echo false)

  echo ${result}
  return $([ "$(shell_identity)" = "bash" ] &&  echo 0 || echo 1)
}

is_bash() {
  shell_name=${1:-"bash"}
  result=$( is_shell "$shell_name" )

  echo ${result}
  return $([ "$result" = "true" ] &&  echo 0 || echo 1)
}

is_zsh() {
  shell_name=${1:-"zsh"}
  result=$(is_shell shell_name)

  echo ${result}
  return $([ "$result" = "true" ] &&  echo 0 || echo 1)
}

# Utils / colors.sh
colours() {
  if which 'tput' > /dev/null; then
    # Foreground Colours
    FG_BLACK=$( tput setaf 0 );
    FG_RED=$( tput setaf 1 );
    FG_GREEN=$( tput setaf 2 );
    FG_YELLOW=$( tput setaf 3 );
    FG_BLUE=$( tput setaf 4 );
    FG_MAGENTA=$( tput setaf 5 );
    FG_CYAN=$( tput setaf 6 );
    FG_WHITE=$( tput setaf 7 );

    FG_RESET=$( tput sgr0 );
  else
    FG_BLACK='';
    FG_RED='';
    FG_GREEN='';
    FG_YELLOW='';
    FG_BLUE='';
    FG_MAGENTA='';
    FG_CYAN='';
    FG_WHITE=$( tput setaf 7 );

    FG_RESET=$( tput sgr0 );
  fi
}

# Utils / text-formats.sh
text_formats() {
  # Text Formatting
  if which 'tput' > /dev/null; then
    TXT_BOLD=$( tput bold )
    TXT_ULINE=$( tput smul )
    TXT_BLINK=$( tput blink )

    TXT_RESET=$( tput sgr0 )
  else
    TXT_BOLD=''
    TXT_ULINE=''
    TXT_BLINK=''

    TXT_RESET=''
  fi
}


# Utils / Notifications
msg_clear() {
  # local msg="$1"
  echo -e "${FG_RESET}"
  sleep .5s
}

# This function displays an informational message with a Blue color.
msg_info() {
  local msg="$1"
  echo -e "${FG_BLUE}${msg}${FG_RESET}"
  msg_clear
}

# This function displays a success message with a green color.
msg_ok() {
  local msg="$1"
  echo -e "${FG_CYAN}${msg}${FG_RESET}"
  msg_clear
}

# This function displays an informational message with a Yellow color.
msg_warn() {
  local msg="$1"
  echo -e "${FG_YELLOW}${msg}${FG_RESET}"
  msg_clear
}

# This function displays an error message with a red color.
msg_error() {
  local msg="$1"
  echo -e "${FG_RED}${msg}${FG_RESET}"
  msg_clear
}

# Utils / spinners.sh

cursorBack() {
  echo -en "\033[$1D"
}


stop_spinner() {
  tput cnorm
}

grid_spinner() {

  trap stop_spinner SIGINT SIGTERM ERR EXIT
  local PID=$!
  local x=0
  local spin='⣾⣽⣻⢿⡿⣟⣯⣷'
  tput civis

  while kill -0 $PID 2>/dev/null; do
    local x=$(((x + 3) % ${#spin}))
    printf "\r%s" "${spin:$x:3}"
    cursorBack
    sleep .1
  done

  stop_spinner
  wait $PID # capture exit code
  return $?
}

slash_spinner() {
  # trap stop_spinner EXIT
  PID=$!
  local i=1
  local spin="/-\|"
  tput civis

  while kill -0 $PID 2>/dev/null; do
  # echo "A: ${#spin}"
  # echo "B: ((i++))"
    printf "\b${spin:((i++))%${#spin}:1}"
    cursorBack
    sleep .1
  done

  stop_spinner
  wait $PID # capture exit code
  return $?
}
